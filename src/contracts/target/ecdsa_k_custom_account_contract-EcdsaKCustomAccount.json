{"transpiled":true,"noir_version":"0.33.0+8ac81b15cd2a3b57493bfbfe444086deac8f3dc8","name":"EcdsaKAccount","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}}],"kind":"struct","path":"types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}}],"kind":"struct","path":"types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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mjntSac1d1oLp7V02lNOa+W01k5r47S2TmvntPZO6+C0jk7r5LTOTuvitK5O6+a07k7r4bSnndbTab2c1ttpfZzW12n9nNbfaQOcNtBpg5w22GlDnDbUacOcNtxpzzhthNNGOm2U05512minjXHaWKc957RxThvvtAlOe95pE502yWmTnTbFaVOdNs1p0532gtNmOG2m01502ktOe9lps5z2itNmO+1Vp81x2mtOm+u01502z2lvOG2+09502gKnveW0hU5b5LTFTlvitKVOW+a05U5b4bSVTlvltNVOe9tpa5z2jtPWOm2d09Y7bYPTNjptk9M2O22L07Y67V2nbXPadqftcNp7TtvptPedtstpHzhtt9M+dNoep33ktL1O+9hp+5z2idM+ddpnTtvvtM+ddsBpXzjtoNMOOe1Lpx122hGnfeW0r5121GnHnHbcad847YTTTjrtlNO+ddppp51x2lmnfee0c04777TvnfaD0y447aLTLjntR6f95LTLTrvitJ+ddtVp15z2i9N+ddp1p91w2k2n/ea0W0677bQ7TvvdaXedds9pbiEQw2kRTovptFhOi+20OE6L67R4TovvtAROS+i0RE5L7LQkTkvqtGROS+60FE5L6bRUTkvttDROS+u0dE5L77QMTsvotEeclslpmZ2WxWlep2V1WjanZXdaDqfldFoup+V2Wh6n5XVaPqfld9qjTivgtIJOK+S0wk4zTivitKJOc9/N7r5v2n1nsvsOYfeduu47Zt13rrrvIHXfyem+79J9l+Qf72l0mvt+Qffdfe578dx3zrnvc3Pflea+h8x9x5f7/iz33VTue5/cdyq57yty3wXkvmfHfe+M+04X9x0n7vtD3HdzuO+9cN8p4b6vwX0XgvueAfcZ/u7z8d1nz7vPdXefme4+j7yN09znaLvPqHaf/+w+W9l9brH7TGD3ebvus2zd58S6z2B1n2/qPjvUfS6n+8xL93mS7rMa3ecgus8YdJ/f5z4bz33unPtMN/d5ae6zyNznfLnP0HKfT+U++8l9rpL7zCL3eUCjnOY+x8Z9Roz7/BX32Sbuc0Pc2sd93oX7LAn3OQ3uMxDc5wu49+6798W795y793O790q79yG79/i698+696a6932691S69yu69wK699m597C594e591659zW59wy59+O84TT3PhL3Hg33/gf3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","debug_symbols":"7P3dbmTrkt773Usf62DEd4RuxTAM2VvbELAhGZZ8JKx791tzFlmcTS5yrV5ZyT8ZqRNVdw9wRrxZ9WTkSP5i/O9/+z/+6//z//f//n/8t//+f/6P//lv//n/9r//7f/6H/+v//K//tv/+O/nf/rf/2b+x//uf/5//st///E//s//9V/+v//r3/7z9Z/+7b/+9//j/P9/+0//9n/+t//rv/7bf8762396dZmOx88rdX5c8fNi0Xzjar86f17tkvPB1XJp2M/Lz58zn69Xu9663ub5chd9vtr0rYvlempRxOflxf/3//RvFo8zeXUm+TiTV2dSjzN5dSb9OJNXZzKPM/n3Z+LX40xenYk8zuTVmejjTF6diT3O5NWZ+ONMXp3JY459fSaPOfb1mTzm2Ndn8phjX5/JY459dSbxmGNfn8ljjn19Jo859vWZgOfYea77sss/OpOOerq8K/+lM/HHmbw6E/Ac+2ln8phjX5/JY459fSaPOfb1mTzm2Fdnko859vWZPObY12fymGNfn8njfuzrM/HHmbw6k8f92Ndn8phjX5/JY459fSaPOfb1mTzm2FdnUo859vWZPObY12fymGNfn8njfuzrM/HHmbw6k8f92Ndncsc59vy/pzMJLXCe1ONMXp1JP87k1ZnM40z+/Zn09TiTV2ci3DP5rPedvuMcG/5Utaca+O+JPc7k1Zn440xenUk8zuTVmeTjTF6dST3O5NWZNPdMPu29+F+ZY23y6Uqb+VWHpPz42XP9xp/9r8xVovb0CV205NfP9reuHten054zYv2lkjf+ntj5C/70F8Wu8FeV65et/M0ZRcbkqaR58ffr7frjeUaVyF/NVrz5NzfjudkXQVHKypXxx7m8eS7xOJc3zyUf5/LmudTjXN48l36cy5vnMo9zeetczv/xcTBvH4w8Dubtg9HHwbx9MI+Z9+8cjD8O5u2DeUy9f+dgHmPv3zmYx9z7dw7mMfj+nYN5TL5vH4w8Jt+/czCPyffvHMxj8v07B/OYfP/OwfjjYN4+mMfk+3cO5jH5/p2DeUy+f+dgHpPv3zmYx+T79sEofPL9rF9wEIVPvp93MLeYfPPXwfSHByPPteuLv+0ltH9K9jiYtw/GHwfz9sHE42DePph8HMzbB1OPg3n7YPpxMG8fzDwO5s2DsetxMG8fjDwO5u2DeUy+f+dgHpPv3zkYfxzM2wfzmHz/zsE8Jt+/czDwyffT7scYfPL9vIO5xeT767+Q/tHBfGKvfi3qVRb1eoORM3+VU5e+36t6PV2s8aLTt21jPyeBdrzQitdbWtHOf/3n1abXC4Nm/WertqdV39Nq7Gk197Rae1rtPa3Omlbj2tOq7Gl1z7QUe6al2DMtxZ5pKfZMS7FnWoo901LsmZZyz7SUe6al3DMt5Z5pKfdMS7lnWso901LumZZyz7SUe6al2jMt1Z5pqfZMS7VnWqo901LtmZZqz7RUe6al2jMt1Z5pqfdMS71nWuo901LvmZZ6z7TUe6al3jMt9Z5pqfdMS71nWpo909LsmZZmz7Q0e6alWzzf46u0umdamj3T0uyZlmbPtDRrpiW91kxLeq2ZlvRaMy3ptWZa0sv3tLpmWtJrzbSk15ppSa9vNC3Z6FOrbvOXVt+qWp8XJWT264P5RrPVP3cw9etgKubVwcg3msS85ulgQj48mOvX7gDR68XVb5V9fuDPi89/5Pla07eujXp6pGv6i3+ibz8pWH4d9Plq4/lqrT9fnW80PH7DV+cbzbvf8NX5RiP6N3x1/PHqgF+db/RB6Bu+Ot/os9s3fHW+0cfNb/jqfKNPyN/w1flGH9O/36ujj3sF5Ffnca+A/Oo87hWQX53HvQLyq+OPVwf86jzuFZBfnce9AvKr87hXQH51HvcKyK/O414B+NWxx70C8qvzuFdAfnUe9wrIr87jXgH51fHHqwN+dR73CsivzuNeAfnVedwrIL86j3sF5Ffnca8A/Or4414B+dV53Cv43Fdn4qkKvfrVq/O4V0B+dR73Csivjj9enc98dVSeH0KuP674d6/O414B+dV53CsgvzqPewWf+uqYPV0s5v7q1XncK/hHXp2Qp4vzig9eHRN/OjyTrl8nrn+e+OPz/81PXPNptjJ9feLf6Tm+X+TEH5/T733ij8/e9z7xx+fpe5+4P078zif++Nx77xN/fJa994k/Pp/e+8QfnznvfeKPz5z/yImnPP3ofFHH2yculzzfV7n8Lyf++mJ3e9qT5y9v7/x8eb7To9O/48vz+DSLfnkeH33RL8/az8lqzy+Puv7l5fnjYPxxMG8fzNpPnR8dzNoPh9rPm4PtxVeMbyedzPX8heTUi18is+vNrNNfMXrZizb/zvX96wS78kWSvnWxXL8i2l9+r/fnC7r2s+d3fUG/0Ufb0OePlJHXBy/o6NU/rx7VXy+RpLxViV3PP/z8Ofwv1/9xkN/oE+unHmTd+7NlzNO/7DOZ68uf/Ec59/4sVfYUHVp//cl/lKOscoxVjrPKCVY5ySqnWOU0q5xBlXP3B9p/UA4rlZuVys1K5WalcrNSuVmp3KxUblYqNyuVh5XKw0rlYaXysFJ5WKk8rFQeVioPK5WHlcqDSmW7UKlsFyqV7UKlsl2oVD43f1nloFLZLlQq24VKZbtQqWwXK5WFlcrCSmVhpbKwUllYqSysVBZWKgsrlYWVysJKZWWlsrJSWVmprKxUVlYqKyuVlZXKykplZaWyslLZWKlsrFQ2ViobK5WNlcrGSmVjpbKxUtlYqWysVHZWKjsrlZ2Vys5KZWelsrNS2Vmp7KxUdlYqOyuVg5XKwUrlYKVysFI5WKkcrFQOVioHK5WDlcrBSuVkpXKyUjlZqZysVE5WKicrlZOVyslK5WSlcrJSuVipzLJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9xrJ9zrJ9zrJ9zrJ9zrJ9fqFS2Vm2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2z1m2L1i2L1i2L1i2L1i2Ly5UKgfL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9gXL9iXL9iXL9iXL9iXL9uWFSuVk2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5k2b5i2b5i2b5i2b5i2b66UKlcLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNtXLNvXLNvXLNvXLNvXLNvXFyqVm2X7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7mmX7hmX7hmX7hmX7hmX75kKl8rBs37Bs37Bs37Bs37Bs37Bs39zd9k3FUzkz9f5PtvPf/nmxTcbzxepvXOyWTz/Zre3lxX80qlsatS2N+pZGY0ujuaXR2tJob2l0ljR6dwX7aY1umYx0y2SkWyaju2vjT2t0y2SkWyYj3TIZ6ZbJSLdMRrZlMrItk5FtmYxsy2R0d/H/aY1umYxsy2RkWyYj2zIZ2ZbJyLdMRr5lMvItk5FvmYzuvnXj0xrdMhn5lsnIt0xGvmUy8i2TUWyZjGLLZBRbJqPYMhndffPNpzW6ZTKKLZNRbJmMYstkFFsmo3tvRbLLr6far4qXP/mPcuTe5fTT6ZhUvyrnt04Zf/wXbvD2XuLP/wWb9xuWqueL+5JfF8tbF8c8/UWTFP/1d8d+/uXxr1x8fOXi887Fd+rzT77qg+Kn9Ln6Kc/ny08vb4WfXfqcfnaF/+X6P9qtXe32rnZnVbu3WHn1G9vteHqD1uvK63X5ct/y9fy8p4LUr49ys9t+Bef1xunr1y7fyOWftyr9VX7O6/L9a5cfX7v8/Nrl75oCatcUULumgGZPATdvV3a1q7vatV3t+q52Y1e7u+6t9K6pqu89VZXl88URL9v9o5xBlTMXqxz2vYa6nv6unT+nvPq7dveVhF5PF2u8uHnw5k/WlueLO359MSRXvvVFSTz/u7J4eVfI+o2rR6/+efWoxr/8j/buyxS/7UH64yBvc5DoO0Ef3kYc9J2gj8uvr10+awYZ1Awi14UaQk498gjNW4TmOcnHQHSrk3xMRLc6Sd/0+ff0u+puzul31e2c0++q+zmn31Vfk51+V31PJpfApkFRWD0Gq8e/8j27U3/AzvNLf1Q/9ddjUr3NpHr3La/f9yTna/+b0uuL1y+sjFXYe+gtNovetB74Z8Z+/tHTfr3x9y1h5/l4T7xRkuvjPfFWJ3n3bwFu56HksutLVy9fuvpVv+x4+l31246nX1/W77I75Ma+Q/4BSDv1k+946yn5V/1p1wevV/bz6JgvZ4b42Sv5bveteyXf6b5xr07mILfulWxBbt0reTb653vtp88zOde86pU8F926V1/UK3keunWv5Fno1r1+r7np/V6/19z0fq/fa256t9f4XnPT+71+r7np/V4XzU2xaG66xZbPL9ProrkpFs1NsWhuikVzUyyam3LR3JSL5qZcNDflornp7qtWP7PXRXMTepHrrXtdNDehV7jeutdFcxN6eeute100N9WiuakWzU33Xjj7qb0umptq0dyE3nt7614XzU3ojbc37hW97vbWvS6am9CLbm/d66K5Cb3i9ta9Lpqb0Mttb93rormpF81NvWhumkVz0yyam2bR3DSL5qZbLNj9Mr0umptm0dw0i+amWTQ3zZ65Sa49c5Nce+YmufbMTXLtmZvk8kW97pmbBL1999a97pmbBL1199a9LpqbZNHcJIvmJlk0N8miuene25Y/tddFc5Msmptk0dwki+YmWTQ36aK5SRfNTbpobtJFc9PdN2x/Zq+L5iZdNDfporlJF81NumhuskVzky2am9A7wW/d66K5Cb0L/Na9Lpqb0DvAb93rornpm+0Lf7/XRXPTN9sX/n6vi+amRfvCZdG+cFm0L1wW7QuXRfvC5XvtCx99fm7D2Otev9Xc9EGv32puer/X+NpPTpV77wC/ef1Krj/P/PWr/pw36rcvXr9/8frji9ePfpp7XfLiUajeH84L7z37SO69J/tTe+1FvaKfnn7bXhM9L9y4V/Rs8U/3+u5nmUTPITfuFT2z3LhXX9Qreha6ca/fa256v9fvNTe93+v3mpve7/V7zU3v9lrfa256v9dFc1Mtmptq0dx07z3Zn9rrormpFs1NtWhuqkVzUy2am3rR3NSL5qZeNDf1ornp3nuyP7XXRXNTL5qbetHc1Ivmpl40N82iuWkWzU2zaG6aRXPTvfdkf2qvi+amWTQ3zaK5aRbNTbNnbtJrz9yk1565Sa89c5Nee+YmvXxRr3vmJr32zE167Zmb9NozN+m1aG6SRXOTLJqbZNHcJIvmpnvvyf7UXhfNTbJobpJFc5Msmptk0dyki+YmXTQ36aK5SRfNTffek/2pvS6am3TR3KSL5iZdNDfpornJFs1NtmhuskVzky2am+69J/tTe100N9miuckWzU22aG6yRXOTL5qbfNHc5Ivm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/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDB/GDD/GDD/GDD/GDD/GBfrHxumB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB9smB8cmB8cmB8cmB8cmB+ci5XPA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODA/ODw/KDerH84KkHlc+nHlQ+n3pQ+XzqQeXzqQeVz6ceVD6felD5fOpB5fOpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sP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H3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYHwyYHwyYHwyYHwyYH4yLlc8B84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MJ84MJ84MJ84MJ84N5sfI5YX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX6wYH6wYH6wYH6wYH6wLlY+F8wPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPNswPNswPNswPNswP9sXK54b5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYH5wYH5wYH5wYH5wblY+TwwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgsP+gXyw+eelD5fOpB5fOpB5XPpx5UPp96UPl86kHl86kHlc+nHlQ+n3pg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceVj4LzA8KzA8KzA8KzA/KxcpngflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBhflBhflBhflBhflBvVj5rDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/aDA/aDA/aDA/aDA/aBcrnw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBx3mBx3mBx3mBx3mB/1i5bPD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/GDA/GDA/GDA/GDA/GBcrHwOmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB9MmB9MmB9MmB9MmB/Mi5XPCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODBfODBfODBfODBfODdbHyuWB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGF+sGF+sGF+sGF+sC9WPjfMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDw7MDw7MDw7MDw7MD87FyueB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB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/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/GDA/GDA/GDA/GDA/GBcrHwOmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB9MmB9MmB9MmB9MmB/Mi5XPCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODBfODBfODBfODBfODdbHyuWB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGF+sGF+sGF+sGF+sC9WPjfMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDw7MDw7MDw7MDw7MD87FyueB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cFh+cG8WH7w1IPK51MPKp9PPah8PvWg8vnUg8rnUw8qn089qHw+9aDy+dQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1sPJZYH5QYH5QYH5QYH5QLlY+C8wPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPKswPKswPKswPKswP6sXKZ4X5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5Qb23HzwDcv+8+MwW9rKety7O63q+Ou16vlxS3rg+R/Pn5Tn2q+z42ast6tUX9RqLes1FvdaiXjnv429cHDNPF6f488Vq/rN6zrv+f6B6kGH9j1Qv4H8lpz+dX716fvCv5LwWGk8/3a7wv1z/Z7/kieV39EueWn5Hv76sX/L0cr6fiV/vcuct7436v9VE0vb8Lt1h//5d2r7VRPJBr72o19nT671F+Kf2Sp6N/vleu54/QVyvPkH4t7qT80Gv3+pOzge9+qJev9WdnA96/V5z0/u9fq+56f1ev9fc9H6v32tuerfX+F5z0/u9LpqbYtHcFIvmpntvxvjUXhfNTbFobopFc1Msmpti0dyUi+amXDQ35aK5KRfNTffeWPOpvS6am3LR3JSL5qZcNDflormpFs1NtWhuqkVzUy2am+69SepTe100N9WiuakWzU21aG6qRXNTL5qbetHc1Ivm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FeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHFeYHDeYHDeYHDeYHDeYH7WLls8H8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMH8oMP8oMP8oMP8oMP8oF+sfHaYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYH3SYHwyYHwyYHwyYHwyYH4yLlc8B84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MB84MJ84MJ84MJ84MJ84N5sfI5YX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX4wYX6wYH6wYH6wYH6wYH6wLlY+F8wPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPFswPNswPNswPNswPNswP9sXK54b5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYb5wYH5wYH5wYH5wYH5wblY+TwwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgwPzgsP9gXyw+eelD5fOpB5fOpB5XPpx5UPp96UPl86kHl86kHlc+nHlQ+n3pg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceVj4LzA8KzA8KzA8KzA/KxcpngflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBhflBhflBhflBhflBvVj5rDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/qDA/aDA/aDA/aDA/aDA/aBcrnw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBx3mBx3mBx3mBx3mB/1i5bPD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/GDA/GDA/GDA/GDA/GBcrHwOmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB9MmB9MmB9MmB9MmB/Mi5XPCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfOD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H1SYH1SYH1SYH1SYH9SLlc8K84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MG84MG84MG84MG84N2sfLZYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYX7QYX7QYX7QYX7QL1Y+O8wPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPBswPBswPBswPBswPxsXK54D5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYT5wYT5wYT5wYT5wbxY+ZwwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP1gwP1gwP1gwP1gwP1gXK58L5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL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yYunCHo/X/72A/lyNH9envPiaOKp2djUbG5qtjY125uanUXN3tuyfm6zsqlZ3dSsbWrWYR++h/bbszQ7nDQ7nDQ7nDQ7XDQ7XDQ7XBfsrmRdsLuSJ+tpBcGSumjPNy3a802L9nzToj3ftGjPNy3a802LZoeLZodLaEkttKQWWlILLamFltRCS2qlJbXSkpr2fNOiPd+0aHa4aHa4aHa4aHa4aHa4aHa4aHa4aHa4jJbURktqoyW10ZKa9nzToj3ftGjPNy3a802L9nzToj3ftGh2uGh2uJyW1E5LaqcltdOS2mlJTbPDRbPDFbSkpj3ftGjPN62gJXXQkppmh4tmh4tmh4tmh4tmh4tmhytpSZ20pKY937Rozzct2vNNi/Z806I937Rozzct2vNNi/Z806LZ4aLZ4SpaUhctqYuW1EVL6qIlddGSumlJ3bSkpj3ftGjPN62mJXXTkrppSd20pG5aUtOeb1q055vW0JJ6aEk9tKSmGcWiGcWiGcWiGcWiGcWiGcWmGcWmGcWmGcWmGcW+YEndNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKPYNKM4NKM4NKM4NKM4NKM4Fyyph2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUh2YUB2YU5YIZxVMQK6lPQaykPgWxkvoUxErqUxArqU9BrKQ+BbGS+hTESupTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFH880JVWEC2pYUbxx1NoaAXRkhpmFH+szqUVREtqmFH8se+HVhAtqWFG8QdSZBUkNKMoNKMoNKMoNKN4vienFQRLaqEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaUZRaUZRaUZRaUZRb1gSa00o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o2g0o2g0o2g0o2g0o2gXLKmNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSdZhSdZhSdZhSdZhT9giW104yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04xi0Ixi0Ixi0Ixi0IxiXLCkDppRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRTJpRTJpRTJpRTJpRzAuW1EkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikUzikUzikUzikUzinXBkrpoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFpRrFpRrFpRrFpRrEvWFI3zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSgOzSgOzSgOzSgOzSjOBUvqoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFgRlFvWBG8RTESupTECupT0GspD4FsZL6FMRK6lMQK6lPQaykPgWxkvoUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BcGSWmhGUWhGUWhGUWhGUS5YUgvNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKArNKCrNKCrNKCrNKCrNKOoFS2qlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWlGUWjGUWjGUWjGUWjGUW7YEltNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKPoNKPoNKPoNKPoNKPoFyypnWYU/d5GUS/rnxfr1fayoLcuzut6vjrter5cUt64Pkfz5+U59qvseGq2NjXbm5qdRc3e24R+brOyqVnd1KxtatY3NRubmiVPUGfo0/k1AHp+0OyPxSfx9NPtCv/L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pRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFoxlFoxlFoxlFoxlFu2BJbTSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSjaDSj6DSj6DSj6DSj6DSj6BcsqZ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFJ1mFINmFINmFINmFINmFOOCJXXQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLQjGLSjGLSjGLSjGLSjGJesKROmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlFMmlHMextFvax/XqxX28uC3rr43L96vvq8ms+XS8ob1+do/rw8x36VHU/N2qZmfVOzsanZ3NRsbWqW847+xsXn242ni8+dhueL1fypfM77/3+kfJCT/Q+VL+B/KadBnV/Nen7wL0Xt0nj66XaF/+X6nw2TZ5ff0jB5fvktDfu2hslzjEzHr3e789b3VgPfajZpe3677rBXb9f+rWaTj5rtTc3Oombvrc4/t1nylPTPN9v1/Hniev15Ir7V3Z2Pmv1Wd3c+atY3Nfut7u581Oz3mqA+aPZ7TVAfNPu9JqgPmv1eE9T7zeb3mqA+aHbTBJWbJqjcNEHde/vG5za7aYLKTRNUbpqgctMElZsmqNo0QdWmCao2TVC1aYK691acz2120wRVmyao2jRB1aYJqjZNUL1pgupNE1RvmqB60wR1721Vn9vspgmqN01QvWmC6k0TVG+aoGbTBDWbJqjZNEHNpgnq3lvkPrfZTRPUbJqgZtMENZsmqFk0QdW1aIKqa9EEVdeiCaquRRNUXb6p2UUTVF2LJqi6Fk1QdS2aoOraNEHJpglKNk1QsmmCkk0T1L23rn5us5smKNk0QcmmCUo2TVCyaYLSTROUbpqgdNMEpZsmqHtvQ/7cZjdNULppgtJNE5RumqB00wRlmyYo2zRBfa9t3x81u2mC+l7bvj9qdtME9b22fX/U7KYJyjZNULZpgvJNExR67/jNm900QaH3jd+8Wd/U7KYJ6pvtJP+g2U0T1DfbSf5Bs5smqG+2k/yDZjdNUJt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJ3pt2kvemneS9aSd5b9pJ3pdvanbRBNWbdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3ks2kn+WzaST6bdpLPpp3kc/mmZhdNULNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5LNpJ/ls2kk+m3aSz6ad5P//9u52N5IjO/P4LeV5P+dqFraxWAwwsBe2d4H94HvfaEkstoZ0U12qqP5T0V8GEqaq8olSxsNgMn+Rc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke5HPSnuRz0p7kc9Ke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USyaUSyaUSyaUSyaUawL1tRFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pNM4pNM4pNM4pNM4p9wZq6aUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUZxaEZxaEZxaEZxaEZxLlhTD80oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDswoxgUziisQq6lXIFZTr0Cspl6BWE29ArGaegViNfUKxGrqFYjV1CsQralhRnEFojU1zCiuQLSmhhnFFYjW1DCjuALRmhpmFFcgWlPDjOIKRGtqmFFcgWhNDTOKKxCtqWFGcQWiNTXMKK5AtKaGGcUViNbUMKO4AtGaGmYUVyBaU8OM4gpEa2qYUVyBaE0NM4orEK2pYUZxBaI1NcworkC0poYZxRWI1tQwo7gC0ZoaZhRXIFpTw4ziCkRraphRXIFoTQ0ziisQralhRnEFojU1zCiuQLSmhhnFFYjW1DCjuALRmhpmFFcgWlPDjOIKRGtqmFFcgWhNDTOKKxCtqWFGcQWiNTXMKK5AtKaGGcUViNbUMKO4AtGaGmYUVyBaU8OM4gpEa2qYUVyBaE0NM4orEK2pYUZxBaI1NcworkC0poYZxRWI1tQwo7gC0ZoaZhRXIFhTC80oCs0oCs0oCs0oygVraqEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaEZRaUZRaUZRaUZRaUZRb1gTa00o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o6g0o2g0o2g0o2g0o2g0o2gXrKmNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSNZhSdZhSdZhSdZhSdZhT9gjW104yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04yi04xi0Ixi0Ixi0Ixi0IxiXLCmDppRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRDJpRTJpRTJpRTJpRTJpRzAvW1EkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikkzikUzikUzikUzikUzinXBmrpoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFoRrFpRrFpRrFpRrFpRrEvWFM3zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSg2zSgOzSgOzSgOzSgOzSjOBWvqoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFoRnFgRnFvGBGcQViNfUKxGrqFYjV1CsQq6lXIFZTr0Cspl6BWE29ArGaegWiNTXMKK5AtKaGGcUViNbUMKO4AtGaGmYUVyBaU8OM4gpEa2qYUVyBaE0NM4orEK2pYUZxBaI1NcworkC0poYZxRWI1tQwo7gC0ZoaZhRXIFpTw4ziCkRraphRXIFoTQ0ziisQralhRnEFojU1zCiuQLSmhhnFFYjW1DCjuALRmhpmFFcgWlPDjOIKRGtqmFFcgWhNDTOKKxCtqWFGcQWiNTXMKK5AtKaGGcUViNbUMKO4AtGaGmYUVyBaU8OM4gpEa2qYUVyBaE0NM4orEK2pYUZxBaI1NcworkC0poYZxRWI1tQwo7gC0ZoaZhRXIFpTw4ziCkRraphRXIFoTQ0ziisQralhRnEFojU1zCiuQLSmhhnFFYjW1DCjuALRmhpmFFegJze1Xta/vVjXUuPrQO+lL53X+J63l0vKex9ul8bLp9v6s8nvXv/bgPu0Ac9ZA5ZnG84fP2A5bcB62oAf8ZNe/OXFZfPBj42yvL044vXFt0BOCxS0QPnsQHV7cV/yTqCiBWpaoIGdQw8xrg8NJLRASgtEa2qhNbXQmlqSFqhogWhNLQMLpBctkNACPbmpdX3ey6pa/fo60DufHHW9rMHXP6e8swZX++wD8M8+gPjsA6D9pFHaTxptWqBBn3Pd9vLRX34pf+ecs+uzD0A++wAe8JMv43a1qq6PrlZ5vbxY46tE736yttxe3PF6aWtdv3jn1Ra3S1UW+frdiPU7r551sey3V49q/Nefvw72CO3886v89av0n1/lo77K+PlVPuqrzJ9f5aO+yvr5VT7qq+zPvgT57KtY/+yrWP/sq1hnX7/5AwNgX7/5AwNw2CU9D1og2t9cnfY3V6ddyXfalfygXckP2pX8UFogowWiNXXQmjpoTR20pg5aUwetqZPW1Elr6qQ1ddKaOmlNnbSmTlpTJ62pk9bUSWvqojV10Zq6aE1dtKYuWlMXramL1tRFa+qiNXXRmrppTd20pm5aUzetqZvW1E1r6qY1ddOaumlN3bSmHlpTD62ph9bUQ2vqoTX10Jp6aE09tKYeWlMPrKn1gjW1XrCm1gvW1HrBmlovWFPrBWtqpXl7pXl7pXl7vWhNLbSmFlpTC62phdbUQmtqoTW10JpaaE1N8/ZK8/ZK8/ZK8/aqtKZWWlMrramV1tRKa2qlNbXSmlppTW20pjZaUxutqY3W1EZraqM1tdGa2mhNbbSmNlpTO62pndbUTmtqpzU1zSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgqzSgq7ZnSSnumtNKeKa20Z0or7ZnSSnumtNKeKa20Z0or7ZnSSnumtNKeKa20Z0or7ZnSSnumtNKeKa20Z0or7ZnSSnumtNKeKa20Z0or7ZnSSnumtNKeKa20Z0or7ZnSSnumtNKeKa20Z0or7ZnSSnumtA6tqYfW1ANrartgTW0XrKntgjW1XbCmtgvW1HbBmtouWFPbBWtqu2BNbRetqYXW1EJraqE1tdCaWmhNLbSmFlpTC62phdbUQmtqpTW10ppaaU2ttKZWWlMrramV1tRKa2qlNbXSmtpoTW20pjZaUxutqY3W1EZraqM1tdGa2mhNbbSmdlpTO62pndbUTmtqpzW105raaU3ttKZ2WlM7ramD1tRBa+qgNXXQmjpoTR20pg5aUwetqYPW1EFr6qQ1ddKaOmlNnbSmTlpTJ62pk9bUNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKNoNKPoNKPoNKPoNKPoNKPoF6ypnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUnWYUg2YUg2YUg2YUg2YU44I1ddCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtCMYtKMYtKMYtKMYtKMYl6wpk6aUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUUyaUSyaUSyaUSyaUSyaUawL1tRFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pFM4pNM4pNM4pNM4pNM4p9wZq6aUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUaxaUZxaEZxaEZxaEZxaEZxLlhTD80oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0oDswo1gUz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FshogZwWKGiBkhaoaIGaFmhggYrW1EVr6qI1ddGaumhNXbSmLlpTF62pi9bURWvqpjV105q6aU3dtKZuWlM3ramb1tRNa+rna3J/DeRvd+Tz55vvDwJtltm/HEL2H+Ihbdp+O8RH+7evayK3x12mx5s8BsvjsDwBy5Nb8/xyiNp/iN5/iNl9iHiI206/1UVm/plzIx7Cth+ZR2F5DJbHt+b55RCx/xCPaKQPvqjaf4jef4jZfoiHuNkPDiH7D6H7D2H7D+H7DxH7D7F/dsv+2S37Z7fsn926f3br/tmt+2e37p/dun926/7Zrftnt+6f3bp/duv+2W37Z7ftn922f3bb/tlt+2e37Z/dtn922/7Zbftnt+2f3b5/dvv+2e37Z7fvn92+f3b7/tnt+2e375/dvn92+/7ZHftnd+yf3bF/dsf+2R37Z3fsn92xf3bH/tkd+2d37J/duX925/7Znftnd+6f3bl/duf+2Z37Z3fun925f3bn/tld+2d37Z/dtX921/7ZXftnd+2f3bV/dtf+2V37Z3ftn929f3b3/tnd+2d375/dvX929/7Z3ftnd++f3b1/dvf+2T37Z/fsn92zf3bP/tk9+2f37J/ds392z/7ZPftn92yf3Xld+w8h+w+h+w9h+w/h+w8R+w+R+w9R+w/R+w+xf3bvv1ct99+rlvvvVcv996rl/nvVcv+9arn/XrXcf69a7r9XLfffq5b771XL/feq5f571XL/vWq5/1613H+vWu6/Vy3336uW++9Vy/33quX+e9Vy/71quf9etdx/r1ruv1ct99+rlvvvVcv996rl/nvVcv+9arn/XrXcf69a7r9XLfffq5b771XL/feq5f571XL/vWq5/1613H+vWu6/Vy3336uW++9Vy/33quX+e9Vy/71quf9etdx/I1nuv5Es999IlvtvJMvnbyH57ece5PO3kPwoUNICFS3Q8zcms9szOs3ibaCBBfoBW0h+EEhogZ6/MZnaa6B8G8hogZwWKGiBkhaoaIGe39TffEJN/oAtJL8d6AdsIflBIKEFUlogowVyWiDYo7uyYY/uyoY9uiub1tRNa+qhNfXQmnpoTT20pp7nPyL8uj2GUq56G6hogZoWaFiB6np6D4ndTmpxeRtIaIGUFshogfzpgXReA+nbQEELlLRARQvUtEADCyTPb2rVWyDNt4GEFkhpgYwWyGmBghYoaYGKFqhpgQYWSGlNrbSmVlpTK62pldbUSmvqh9y+vhK9BPKPHocRVb+9Nvr1par6a5xBxXnIbfEPjCOsOPrkOCkvf9lMtbdxjBXHWXGCFSefHeeaWxx/G6dYcZoVZ1Bx/GLFEVacp7fy9XJXV371jPtbHGPFcVacYMVJVpxixWlWnEHFiYsVR1hxWK0crFYOVisHq5WD1crBauVgtXKwWjlZrZygVl7/pl9e+f51XX+99CGvi+zsL8N4/8LrN99h3/0O/+53xPe9Y/2LfXnh+38bSXshY/3Vr+/z6/v8l/e9e6Znvxyvq1//28gvCa/vfod89zv0u99h3/0O/+53vPvfZq6XE3lUvn7H2/PY8uU/h9XXV+J+EXzv76TysE+v7/r0L+94t5InXr6fKf12Hq0bYei3eeZPfvrXo71+9+lvXzs39iaXXP8wzvcvD29Kov7yWk37x+/k/SvDPySJYpLYM5N864x9/1LwnUnefnps/fTc+um19dPf76H/dkp/7/SfP/vx3zx/37/M+biPl70fr3/64//7KbX+Lb688v3/An27Wbfl9QexSf/33+q33yLf/xb9/rfY97/Fv/8t8f1vye9/y/u/IrbdlpTy5i39nW9Z/5ZfXvnuKSB9vdxsK531+/Xr+rf/+0///rd/+ue//8//WO/58n/+n3/9l//827/962//+p//73//+v+sF/9/","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_format","notify_set_min_revertible_side_effect_counter","directive_invert","directive_integer_quotient"]},{"name":"constructor","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}}],"kind":"struct","path":"types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}}],"kind":"struct","path":"types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_contract_instance_internal","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","key_registry_get_stored_keys_hint","get_public_keys_and_partial_address","notify_created_note","get_key_validation_request","unsafe_rand","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(noinitcheck)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}}],"kind":"struct","path":"types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}}],"kind":"struct","path":"types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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UR8i60P0+hD12e312e312e312e312e312e312e312e312e312e312R312R312R312R312R312R312R312R312R312R312Z312Z312Z312Z312Z312Z312Z312Z312Z312Z312d3rs7vXZ3evz+5en929Prt7fXb3+uzu9dnd67O712f3qM/uUZ/doz67R312j/rsHvXZPeqze9Rn96jP7lGf3W1ZdojRdoghO8TQHWLYDjF8hxixQ4zcIUbfIcYOed52yPO2Q563O+S5qp+/xdTU67eYT19WrxrLcv2i3OKzxs96FKbHYHocpidgehKmp8P0DJYeWWB6GkwPzJ8F5s8C82eB+bPA/Flg/iwwfxaYPyvMnxXmzwrzZ4X5s8L8WWH+rDB/Vpg/K8yfFebPBvNng/mzwfzZYP5sMH82mD8bzJ8N5s8G82eD+bPD/Nlh/uwwf3aYPzvMnx3mzw7zZ4f5s8P82WH+HDB/Dpg/B8yfA+bPAfPngPlzwPw5YP4cMH8OmD9nrT8/h7iH5aZfMPQMW4WQ+hB65xDZViGsPoTXh7iHI3W5hOi6nossD3EPSEC76yVEX1Yh7mAFFtI+tbYw/3WIexyGfi1Eqw8h9SG+Ibv1sxDPV9mmq3zTVbHpqtx0Vd901dhwlXzLgd4bV7VNV8mmq3TTVbbpKt90VWy6Kjdd1TddtWlttE1ro21aG23T2mib1kbbtDbaprXRNq2NtmlttE1ro21aG7JpbcimtSGb1oZsWhuyaW3IprUhm9aGbFobsmltyKa1oZvWhm5aG7ppbeimtaGb1oZuWhu6aW3oprWhm9aGblobtmlt2Ka1YZvWhm1aG7ZpbdimtWGb1oZtWhvf8AVoe634//oeiHzDd5q/N8Q3fE35aoj080MNM+XS1v1jgFYc4C67OH2cW+tY8teDdI/9D2uX1naqplchvD5E1IfI+hC9PsQoD3GPXZzXQrT6EPfY/2jevhZC60NYfQivD3GP7D6VmpcQvqxCZH2IXh9ilIe4y+7mKyFafYh7ZLeM6zOM2zqE1oew+hBeH+Iu2d37NURbhcj6EL0+xKgOoctSH6LVh5B7h+irEFofwupD3CO7rZ+/cDMb6xBRHyLrQ/T6EPfIbnO5hhgvQ9y4MfzyA/uf9NzjYRB31dNgegSmR2F6DKbHYXoCpidhejpMD8yfBebPAvNngfmz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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","pack_returns","directive_invert","directive_integer_quotient"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000906cb9c3"},{"kind":"string","value":"EcdsaPublicKeyNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000906cb9c3"},{"kind":"string","value":"EcdsaPublicKeyNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"public_key","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"EcdsaKAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"EcdsaKAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"EcdsaKAccount::entrypoint_parameters"}}],"kind":"struct","path":"EcdsaKAccount::entrypoint_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"signing_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signing_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"EcdsaKAccount::constructor_parameters"}}],"kind":"struct","path":"EcdsaKAccount::constructor_abi"}]}},"file_map":{"101":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"},"106":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes}, note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions, note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor. \n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<N, M>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<N, M>(self) -> Note where Note: NoteInterface<N, M> {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<N, M>(self) -> Note  where Note: NoteInterface<N, M> {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"107":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"124":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n"},"126":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"127":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"135":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"136":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n"},"138":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N, M> {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32, let M: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"140":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"147":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"151":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"161":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"164":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"165":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/stored_keys.nr","source":"use crate::keys::public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH};\nuse dep::protocol_types::traits::{Serialize, Deserialize};\n\n// This struct represents how public keys are stored in the key registry. We store not just the keys themselves but also\n// their hash, so that when reading in private we can perform a historical read for the hash and then show that it\n// corresponds to a preimage obtained from an unconstrained hint. We do store the keys keys regardless as they might be\n// needed during public execution, and since we need to broadcast and produce hints in some standardized way.\n// While it might seem odd to create a struct for what is effectively some data and a pure function called on it, state\n// variables rely on serializable structs in order to persist data to storage, so we must use this abstraction.\nstruct StoredKeys {\n    public_keys: PublicKeys,\n    hash: Field,\n}\n\nimpl StoredKeys {\n    // Instances of StoredKeys are expected to only be created by calling this function so that we guarantee that the\n    // hash field does indeed correspond to the hash of the keys. Ideally we'd forbid direct access to the struct, but \n    // Noir doesn't yet support private members.\n    fn new(public_keys: PublicKeys) -> Self {\n        Self { public_keys, hash: public_keys.hash().inner }\n    }\n}\n\n// Our serialization is the concatenation of the public keys serialization plush the hash, so we need one extra field.\nglobal STORED_KEYS_LENGTH: u32 =  PUBLIC_KEYS_LENGTH + 1;\n\nimpl Serialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn serialize(self) -> [Field; STORED_KEYS_LENGTH] {\n        // The code below is equivalent to:\n        // [ ...self.public_keys.serialize(), self.hash ]\n\n        let mut array = [0; STORED_KEYS_LENGTH];\n\n        let serialized_keys = self.public_keys.serialize();\n        for i in 0..serialized_keys.len() {\n            array[i] = serialized_keys[i];\n        }\n\n        array[PUBLIC_KEYS_LENGTH] = self.hash;\n\n        array\n    }\n}\n\nimpl Deserialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn deserialize(array: [Field; STORED_KEYS_LENGTH]) -> Self {\n        // The code below is equivalent to:\n        // Self { public_keys: PublicKeys::deserialize(array[0 : PUBLIC_KEYS_LENGTH]), hash: array[PUBLIC_KEYS_LENGTH] }\n\n        let mut serialized_keys = [0; PUBLIC_KEYS_LENGTH];\n        for i in 0..serialized_keys.len() {\n            serialized_keys[i] = array[i];\n        }\n\n        let hash = array[PUBLIC_KEYS_LENGTH];\n\n        Self { public_keys: PublicKeys::deserialize(serialized_keys), hash }\n    }\n}\n"},"166":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\nuse crate::keys::constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\nstruct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\ntrait ToPoint {\n    fn to_point(self) -> Point;\n}\n\nstruct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nstruct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : NpkM { inner: Point::empty() },\n            ivpk_m : IvpkM { inner: Point::empty() },\n            ovpk_m : OvpkM { inner: Point::empty() },\n            tpk_m : TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m.inner == other.npk_m.inner ) &\n        ( self.ivpk_m.inner == other.ivpk_m.inner ) &\n        ( self.ovpk_m.inner == other.ovpk_m.inner ) &\n        ( self.tpk_m.inner == other.tpk_m.inner )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x:serialized[0], y:serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x:serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x:serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x:serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"169":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n"},"180":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\nstruct EncryptedLogIncomingBody<let M: u32> {\n    plaintext: [u8; M]\n}\n\nimpl<let M: u32> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, let N: u32>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, let MR: u32>(\n        event: T,\n        randomness: Field\n    ) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_hiding_point(_self: Self) -> Point {\n            crate::generators::Ga1\n        }\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_nullifier(_self: Self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n            1\n        }\n\n        fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n            let note_type_id_bytes: [u8; 32] = AddressNote::get_note_type_id().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        // 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        // the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        // implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        // 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            comptime { EventSelector::from_signature(\"TestEvent(Field,Field,Field)\") }\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes: [u8; 32] = randomness.to_be_bytes();\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 185, 29, 14, 152, 216, 130, 219, 151, 80, 185, 43, 223, 167, 8, 89, 189, 88, 188, 101, 137, 255, 136, 84, 252, 79, 18, 52, 3, 110, 54, 54, 206, 244, 209, 246, 226, 207, 247, 143, 253, 211, 75, 160, 224, 172, 41, 45, 7, 208, 137, 90, 56, 59, 4, 234, 48, 53, 23, 130, 230, 49, 249, 142, 243, 170, 72, 183, 242, 49, 124, 46, 52, 198, 75, 55, 102, 56, 89, 254, 67, 59, 157, 249, 120, 184, 67, 154, 16, 148, 227, 93, 37, 120, 199, 93, 166, 80, 127, 173, 52, 80, 135, 87, 1, 168, 164, 51, 48, 126, 120, 47, 102, 211, 227, 234, 170, 208, 99, 111, 198, 170, 226, 156, 244, 241, 174, 206, 30\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"},"181":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high: [u8; 32] = self.eph_sk.hi.to_be_bytes();\n        let serialized_eph_sk_low: [u8; 32] = self.eph_sk.lo.to_be_bytes();\n\n        let address_bytes: [u8; 32] = self.recipient.to_field().to_be_bytes();\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash_with_separator\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"},"182":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let NB: u32, let MB: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        for i in 0..encrypted_note_log_from_typescript.len() {\n            assert_eq(log[i], encrypted_note_log_from_typescript[i]);\n        }\n        assert_eq(encrypted_note_log_from_typescript.len(), log.len());\n    }\n}\n"},"183":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"185":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_current_public_keys, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL\n};\n\nunconstrained fn compute_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    )\n}\n\nfn compute<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    inner_compute: fn(AztecAddress, Field, Field, OvpkM, IvpkM, AztecAddress, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute_unconstrained);\n    }\n}\n"},"189":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"2":{"path":"std/array.nr","source":"use crate::cmp::Ord;\nuse crate::convert::From;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = unsafe {\n            // Safety: These indices are asserted to be the sorted element indices via `find_index`\n            let sorted_index: [u32; N] = self.get_sorting_index(ordering);\n\n            for i in 0..N {\n                let pos = find_index(sorted_index, i);\n                assert(sorted_index[pos] == i);\n            }\n\n            sorted_index\n        };\n\n        // Sort the array using the indexes\n        let mut result = self;\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u32; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Convert a sequence of bytes as-is into a string.\n    /// This function performs no UTF-8 validation or similar.\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<let N: u32>(a: [u32; N], find: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"},"202":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n"},"203":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"22":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"221":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"222":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"223":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"226":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"227":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"23":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"230":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"234":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"236":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"237":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"24":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"240":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"266":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"27":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"318":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"32":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"325":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-contracts/contracts/ecdsa_public_key_note/src/lib.nr","source":"use dep::aztec::prelude::{AztecAddress, FunctionSelector, NoteHeader, NoteInterface, NoteGetterOptions, PrivateContext};\n\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal ECDSA_PUBLIC_KEY_NOTE_LEN: Field = 5;\n// ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ECDSA_PUBLIC_KEY_NOTE_BYTES_LEN: Field = 5 * 32 + 64;\n\n// Stores an ECDSA public key composed of two 32-byte elements\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[aztec(note)]\nstruct EcdsaPublicKeyNote {\n    x: [u8; 32],\n    y: [u8; 32],\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NoteInterface<ECDSA_PUBLIC_KEY_NOTE_LEN, ECDSA_PUBLIC_KEY_NOTE_BYTES_LEN> for EcdsaPublicKeyNote {\n    // Cannot use the automatic serialization since x and y don't fit. Serialize the note as 5 fields where:\n    // [0] = x[0..31] (upper bound excluded)\n    // [1] = x[31]\n    // [2] = y[0..31]\n    // [3] = y[31]\n    // [4] = npk_m_hash\n    fn serialize_content(self) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n\n        for i in 1..32 {\n          let byte_x: Field = self.x[31 - i] as Field;\n          x = x + (byte_x * mul);\n          let byte_y: Field = self.y[31 - i] as Field;\n          y = y + (byte_y * mul);\n          mul *= 256;\n        }\n\n        let last_x = self.x[31] as Field;\n        let last_y = self.y[31] as Field;\n\n        [x, last_x, y, last_y, self.npk_m_hash]\n    }\n\n    // Cannot use the automatic deserialization for the aforementioned reasons\n    fn deserialize_content(serialized_note: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> EcdsaPublicKeyNote {\n        let mut x: [u8; 32] = [0; 32];\n        let mut y: [u8; 32] = [0; 32];\n\n        let part_x:[u8; 32] = serialized_note[0].to_be_bytes();\n        for i in 0..31 {\n            x[i] = part_x[i + 1];\n        }\n        x[31] = serialized_note[1].to_be_bytes::<32>()[31];\n\n        let part_y:[u8; 32] = serialized_note[2].to_be_bytes();\n        for i in 0..31 {\n            y[i] = part_y[i + 1];\n        }\n        y[31] = serialized_note[3].to_be_bytes::<32>()[31];\n\n        EcdsaPublicKeyNote { x, y, npk_m_hash: serialized_note[4], header: NoteHeader::empty() }\n    }\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl EcdsaPublicKeyNote {\n    pub fn new(x: [u8; 32], y: [u8; 32], npk_m_hash: Field) -> Self {\n        EcdsaPublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}\n"},"327":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all"},"328":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:TokenNote\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([note_hash_for_nullify, secret],GENERATOR_INDEX__NOTE_NULLIFIER)\n    }\n\n    // docs:start:compute_note_hiding_point\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n    // docs:end:compute_note_hiding_point\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiller can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"55":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"65":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            \n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7-i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7-i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"67":{"path":"/home/john-play/Documents/joaolago1113/aztec/aztec-wallet-ui-starter/original_54/src/main.nr","source":"// Account contract that uses ECDSA signatures for authentication on the same curve as Ethereum.\n// The signing key is stored in an immutable private note and should be different from the signing key.\ncontract EcdsaKAccount {\n    use dep::aztec::prelude::{PrivateContext, PrivateImmutable};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n        keys::getters::get_current_public_keys\n    };\n\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness\n    };\n\n    use dep::ecdsa_public_key_note::EcdsaPublicKeyNote;\n\n    #[aztec(storage)]\n    struct Storage {\n        public_key: PrivateImmutable<EcdsaPublicKeyNote>,\n    }\n\n    // Creates a new account out of an ECDSA public key to use for signature verification\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn constructor(signing_pub_key_x: [u8; 32], signing_pub_key_y: [u8; 32]) {\n        let this = context.this_address();\n        let this_keys = get_current_public_keys(&mut context, this);\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n\n        let mut pub_key_note = EcdsaPublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this_keys.npk_m.hash());\n        storage.public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note_with_keys(&mut context, this_keys.ovpk_m, this_keys.ivpk_m, this));\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[aztec(private)]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[aztec(private)]\n    #[aztec(noinitcheck)]\n    #[aztec(view)]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Load public key from storage\n        let storage = Storage::init(context);\n        let public_key = storage.public_key.get_note();\n\n        // Load auth witness\n        let witness: [Field; 64] = unsafe {\n            get_auth_witness(outer_hash)\n        };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify payload signature using Ethereum's signing scheme\n        // Note that noir expects the hash of the message/challenge as input to the ECDSA verification.\n        let outer_hash_bytes: [u8; 32] = outer_hash.to_be_bytes();\n        let hashed_message: [u8; 32] = std::hash::sha256(outer_hash_bytes);\n        std::ecdsa_secp256k1::verify_signature(public_key.x, public_key.y, signature, hashed_message)\n    }\n}\n"},"68":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n * \n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\nunconstrained pub fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"71":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: Field = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: Field = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS = 2;\n\n// docs:start:fee-payload-struct\nstruct FeePayload {\n  function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n  nonce: Field,\n  is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n    for i in 0..MAX_FEE_FUNCTION_CALLS {\n      fields.extend_from_array(self.function_calls[i].serialize());\n    }\n    fields.push(self.nonce);\n    fields.push(self.is_fee_payer as Field);\n    fields.storage\n  }\n}\n\nimpl Hash for FeePayload {\n  fn hash(self) -> Field {\n    poseidon2_hash_with_separator(\n      self.serialize(),\n      GENERATOR_INDEX__FEE_PAYLOAD\n    )\n  }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"72":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\n\nuse crate::entrypoint::function_call::{FunctionCall, FUNCTION_CALL_SIZE_IN_BYTES};\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u64 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u64 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u64 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\nstruct AppPayload {\n  function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n    for call in self.function_calls {\n      fields.extend_from_array(call.serialize());\n    }\n    fields.push(self.nonce);\n    fields.storage\n  }\n}\n\nimpl Hash for AppPayload {\n  fn hash(self) -> Field {\n    poseidon2_hash_with_separator(\n      self.serialize(),\n      GENERATOR_INDEX__SIGNATURE_PAYLOAD\n    )\n  }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"75":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\nstruct AccountActions<Context> {\n  context: Context,\n  is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier = poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"76":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::poseidon2_hash_with_separator\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        comptime {\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\")\n    },\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field\n) {\n    let result: Field = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"consume((Field),Field)\")\n    },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field\n) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\")\n    },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_reject_all(bool)\")\n    },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"81":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"82":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"83":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let NB: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"85":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"86":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"88":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"91":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"92":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"93":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"94":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"98":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n"},"99":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"}}}